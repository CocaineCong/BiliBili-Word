# 扫码登录原理

在这个互联网时代，扫码似乎离不开我们。坐地铁要扫码，做核酸要扫码，登录也要扫码...
我们今天就用登录作为例子来讲一下扫码的原理。

首先我们先简单了解一下登录的原理，
我们的信息是存放在远程的电脑里，我们把这个远程的电脑称为服务器。

那么如果我们想要获取自己的信息，就需要用自己的密码去登录认证。让服务器知道这次请求是你本人，而不是其他人。

举个例子：
这是你，这是你的账号密码，当你发送给服务器的时候，服务器就会返回你的信息，而不是其他人的信息。

那么是谁帮我们进行传输的呢，一般是HTTP/HTTPS这个邮差帮忙传输的。

我们都知道 HTTP 是无状态的，无状态是指服务器是不知道这一次的 HTTP 请求是谁发送的，需要我们自己在 HTTP 上面带上我们的认证信息。也就是我们的账号密码。

我们每点击一个按钮其实就是发送了一次http请求，但如果一直需要我们输入密码来认证是本人操作的话，这会是一件很麻烦的事情。

所以当我们第一次登录的时候，也就是将我们的密码传送给服务器之后，

这里说一句题外话，我们在页面输入密码之后，会在前端，也就是浏览器页面，对我们输入的密码进行加密操作，保护我们的密码，再丢到网络中。

用b站作为例子，我们点击登录，随便输入账号密码，点击键盘上的F12，点击network这个选项，先删除之前的请求记录，点击登录，完成验证码，就可以抓到这一次的登录请求包了，查看请求的参数，也就是第一次携带给服务器的信息，username就是你的账号，password就是加密后的密码，validate以及一下这几个参数就是验证信息，看起来像极验平台的。大多数网站就是这么处理密码的，这样更安全，那有没有其他的网站不是这样处理的呢？

有，比如说，福州大学教务处的网站：我们打开F12，点击本科生，然后随便填写一个验证码，尔康！！！福州市闽侯县的县一流大学的教务处竟然是。。。明文传输！！不过学校的系统都在校园内网中，一般人是进不去，应该是非常的安全。

那还有没有大家所熟知的呢？有！！豆某瓣网站！我们随便输入一下，账号密码。然后打开F12，尔康！！就是这个请求，直接用明文密码传输！

这是一个不好的行为，因为请求可能会在传输过程中被截了，也就是你的账号密码，在网络传输的过程中会被黑客截取，就可以直接拿明文密码登录网站了，并且很多人的不同网站都是用同一个密码，或是相似的密码，那就导致这个人的全网信息都会被撞库，而这将会引发一连串的个人数据的泄漏，这一点我们以后有机会再详细聊聊。

而如何应对这种网站呢？就是提意见。拉到下方，提取意见：你好！我觉得你们网站的登陆方式有问题。应该让前端进行一个非对称的加密传输密码，而不是完整的用铭文形势。

>回信：您好，你在教我写代码？跑题了，开个玩笑。

话说回来，登陆后呢，服务器就会返回一张临时通信证，
一般叫token，token相当于你在该网站上的身份证，用来证明你的身份，而这个临时是有时间限制的，可能是一天，也可能是两小时，这也就是为什么有时候有些网站，在隔一段时间再访问的时候，就会提醒我们身份认证过期，重新登录。
当然一般为了用户体验，也会存在一个 referToken，也就是刷新token，这个token的过期时间一般会很长，这样用户就可以长时间不访问，下一次访问的时候也不需要重新登录。

token 会加在每一次的请求上。比如 当你打开个人信息页面的时候，HTTP会带上你的token奔去服务器，这样服务器就能返回你的信息啦。

那么了解完传统的密码登录之后，我们再来讲讲扫码登录，其实本质上和输入密码是一样，都是为了获取 token，就是该网站的临时身份证。
只是换了一种形式。

我们用B站的扫码登录来举例子：
用户进入网页端的扫码登录界面，

此时网页会从服务端获取一个二维码图片以及获取该二维码的状态（已授权，已过期，已取消等等...）。

那么服务端在生成二维码图片的时候，会生成一个uuid(世界上永远不会重复的一段字符串)和二维码进行关联。并将uuid存入服务器的数据库中，用uuid代指这个二维码。

当用户登录B站的客户端，也就是移动端，也就是App，对着二维码进行扫码授权登录的操作后。

App端就会从二维码中读取到uuid，带着APP内的身份信息访问APP端的服务器。

APP端的服务器获取到用户的身份信息之后呢，就会将用户的个人信息更新到上文所述的uuid所在的数据库中

那么我们上文说过这个uuid是和二维码绑定的，现在这个二维码上面已经有了用户的信息，也就是这个二维码上面已经有了我们的密码，也就完成了我们最初所说的 输入账号密码的操作。那这个二维码上面的密码是怎么来的呢？我们在app端是已登录的状态，所以我们的信息在app端是有的，app端帮我们将我们的信息传送到这个二维码上面而已。怎么送的呢？就是上文所说的，获取二维码的uuid，将uuid和app端的 token 信息传给服务器，就能通过服务端的登录认证，让web端拿到了app端的信息。

此时Web端服务器就能拿到对应的用户个人信息，就知道这个人是谁了，就能生成登录所需要认证信息，也就是token，返回给浏览器。那么用户在Web端就拿到了临时身份证也就是token，也就完成了登录。


那么我们来实战一下，我们打开B站的扫码登录


![login](./static/login.png)


发现 这里有一个oauthkey，这个就是上文我们所提到的uuid的作用，用来绑定这一次的二维码。

然后我们发现这里返回的信息是`Can't scan~`意思是扫不到。
并且似乎隔一段时间就会有一次的，

以上种种情况说明了，B站是采用轮询的方式进行扫码登录，什么是轮询呢？

这里浏览器会每隔一段时间带着uuid来问服务器，我扫码了吗？服务器会说，没有，这个uuid对应的二维码没有信息。

超过了一定的时间，服务器就会说这个二维码过期了，需要刷新！

当我们扫码，但未授权，我们可以看到此时二维码的状态为这样。

当我们授权登录之后，二维码变成了这种状态。

扫码之后能我们会发现有这么一个东西，一个sso的列表里面带有四个ticket，至此我们可以推断出B站的登录采用了授权Ticket的方式。

而这四个ticket对应的系别分别是bilibili游戏，bigfun，bigfunapp，bilibili主站。然而正当我想回去补点素材的时候，发现又新增了两个系统，这两个系统其实都是bilibili漫画，只是域名不一样而已，接下去就发现了一个小破站的bug，这两个新加的系统似乎有问题，去到bilibili漫画，发现并没有我的个人信息，但是当我打开F12检查的时候，发现这个就是我的uid。这说明其实漫画这边已经知道我是谁了，但是出了一些bug，没有传送到漫画的后端。估计是正在进行灰度吧...

这个bug我们就先放一边，那么这一次的登录，让你登录了上海幻电信息科技有限公司的六个系统。那这是怎么做到的呢。其实这就是sso，不是sos啊，全称 single sign on，也就是单点登录。这个有机会我们后面再详细聊一下，我们这里只是简单的了解一下这个sso。当一个企业不断做大做强的时候，就会有不同的系统，而为了方便同一个用户去访问不同的系统，比如blibili主站和bilibili游戏，就会把这两个系统的登录认证抽离出来，让用户一次登录，就能丝滑享受几个系统的信息。

那么ticket是什么呢？

首先我先说明，我不是B站员工，我只是在用B站作为例子。我不知道BiliBili主站实际是如何划分功能模块的。
我们假设首页可以分成很多个系统模块。比如说上方的搜索，首页的推荐，下方的推广，随着业务的扩充，这些系统是可以拆分到不同部门去开发维护的。但如果我们要获取到我们的信息，就要拿我们的密码去各个部门换取token，那么每个部门除了自己的业务之外，又要自己去花额外的时间验证这个密码是否正确，这是一件很麻烦的事情，这多是一件美逝。所以呢，我们就会把登录认证抽离出来，有专门的登录验证系统，去验证我们的身份。而这个登录系统返回的ticket是在各个系统都通用的。

比如这些系统都是游乐园里面的设施，登录系统就是给你门票，让你可以在游乐园里面的各个设施玩耍。

Web 端服务器在扫码完成后，返回的是一个授权 Ticket，之后需要 Web 端带着这个 Ticket 调用目标服务器的接口进行身份的验证同步。

这种方式可以支持 多站点跨站登录身份信息 的同步，适用服务多站点的扫码登录服务；

ok，这期视频我们通过传统登录讲到扫码登录，然后又深入到了系统中对于用户信息的认证。本来是想讲扫码，但好像更多偏向了登录。本视频，都是本着交流学习的目的，我肯定会有地方讲错，也欢迎大家弹幕或是评论一起讨论。

那么下一期我们来聊聊，我们最常用的搜索引擎。

